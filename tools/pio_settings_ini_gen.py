#!python

import re

def extract_instructions(section_content):
   lines = section_content.split('\n')
   instructions = []
   
   in_array = False
   
   for line in lines:
       # Start of instruction array
       if '_program_instructions[] = {' in line:
           in_array = True
           continue
       
       # End of array
       if in_array and line.strip() == '};':
           break
       
       # Extract instruction lines
       if in_array:
           # eg: 0x6221, // 0: out x, 1 side 0 [2]
           match = re.match(r'\s*(0x[0-9a-fA-F]+),\s*//\s*\d+:\s*(.+)', line)
           if match:
               hex_val = match.group(1)
               assembly = match.group(2).strip()
               instructions.append((hex_val, assembly))
   
   return instructions

def extract_program_section(header_content):
   lines = header_content.split('\n')
   start_idx = None
   end_idx = None
   
   for i, line in enumerate(lines):
       if line.strip().startswith('#define'):
           start_idx = i
           break
   
   seen_array = False
   for i, line in enumerate(lines):
       if start_idx is not None and i > start_idx:
           if '_program_instructions[] = {' in line:
               seen_array = True
           elif seen_array and line.strip() == '};':
               end_idx = i
               break
   
   if start_idx is not None and end_idx is not None:
       return '\n'.join(lines[start_idx:end_idx+1])
   else:
       return None

def extract_wrap_points(section_content):
   wrap_target = None
   wrap_end = None
   
   wrap_target_match = re.search(r'#define\s+\w+_wrap_target\s+(\d+)', section_content)
   if wrap_target_match:
       wrap_target = int(wrap_target_match.group(1))
   
   wrap_end_match = re.search(r'#define\s+\w+_wrap\s+(\d+)', section_content)
   if wrap_end_match:
       wrap_end = int(wrap_end_match.group(1))
   
   return wrap_target, wrap_end

def extract_text_instructions(instructions):
    text_instructions = []
    for hex_val, assembly in instructions:
        # remove extra whitespaces
        clean_assembly = assembly.strip()
        text_instructions.append(clean_assembly)
    return text_instructions

def generate_ini(wrap_target, wrap_end, instructions):
   
   ini_content = "; All number literals are in decimal format\n"
   ini_content += "; Boolean literals are written in lowercase: true and false\n"
   ini_content += "[settings]\n"
   ini_content += f"wrap_start = {wrap_target if wrap_target is not None else 0}\n"
   ini_content += f"wrap_end = {wrap_end if wrap_end is not None else 0}\n"
   ini_content += "sideset_count = 0\n"
   ini_content += "sideset_opt = false\n"
   ini_content += "sideset_to_pindirs = false\n"
   ini_content += "sideset_base = -1\n"
   ini_content += "in_base = -1\n"
   ini_content += "out_base = -1\n"
   ini_content += "set_base = -1\n"
   ini_content += "jmp_pin = -1\n"
   ini_content += "set_count = -1\n"
   ini_content += "out_count = -1\n"
   ini_content += "push_threshold = 32\n"
   ini_content += "pull_threshold = 32\n"
   ini_content += "fifo_level_N = -1\n"
   ini_content += "in_shift_right = false\n"
   ini_content += "out_shift_right = false\n"
   ini_content += "in_shift_autopush = false\n"
   ini_content += "out_shift_autopull = false\n"
   ini_content += "autopull_enable = false\n"
   ini_content += "autopush_enable = false\n"
   ini_content += "status_sel = false\n"
   ini_content += "pindir = ffffffff ; hex value, without any prefix. lsb is pin0, 0=out, 1=in \n"
   ini_content += "\n"
   
   ini_content += "; ====== CONTENT BELOW WAS GENERATED BY THE HELPER. DO NOT CHANGE. ======\n"
   ini_content += "\n"
   
   ini_content += "[instructions]\n"
   for i, (hex_val, assembly) in enumerate(instructions):
       ini_content += f"{i} = {hex_val}  ; {assembly}\n"

   ini_content += "[instruction_text]\n"
   text_instructions = extract_text_instructions(instructions)
   for i, text_assembly in enumerate(text_instructions):
      ini_content += f"{i} = {text_assembly}\n"
   
   return ini_content

# main
if __name__ == "__main__":
   import sys
   if len(sys.argv) > 1:
       with open(sys.argv[1], 'r') as f:
           content = f.read()
       
       section = extract_program_section(content)
       if section:
           wrap_target, wrap_end = extract_wrap_points(section)
           instructions = extract_instructions(section)
           
           # Generate INI format
           ini_output = generate_ini(wrap_target, wrap_end, instructions)
           print(ini_output)
       else:
           print("Could not extract section")
   else:
       print("Usage: python test.py <assembled header_file>")

